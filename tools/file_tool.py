from langchain.tools import BaseTool
from typing import Optional, Type
from pydantic import BaseModel, Field
import os
from pathlib import Path
from datetime import datetime


class FileInput(BaseModel):
    action: str = Field(description="Action to perform: 'read', 'write', or 'append'")
    filename: str = Field(description="Name of the file to operate on")
    content: Optional[str] = Field(default="", description="Content to write (for write/append actions)")


class FileTool(BaseTool):
    name = "file_processor"
    description = "Read from and write to files for report generation and data storage"
    args_schema: Type[BaseModel] = FileInput

    def _run(
        self,
        action: str,
        filename: str,
        content: str = "",
        run_manager: Optional[any] = None,
    ) -> str:
        try:
            # Ensure operations are confined to a safe output directory
            output_root = Path(os.getenv("OUTPUT_DIR", "./outputs")).resolve()
            output_root.mkdir(parents=True, exist_ok=True)

            # Normalize and sanitize the filename
            # Disallow absolute paths and parent traversal
            if filename.startswith("/") or ".." in filename:
                return "File operation error: Unsafe filename/path"

            # Replace path separators to avoid nesting
            sanitized = filename.replace("\\", "_").replace("/", "_")

            # Enforce allowed extensions for write-like operations
            allowed_exts = {".md", ".txt"}
            target_path = (output_root / sanitized).resolve()

            # Ensure the final path is still under output_root
            if not str(target_path).startswith(str(output_root)):
                return "File operation error: Path escapes output directory"

            if action.lower() == "read":
                if target_path.exists():
                    with target_path.open('r', encoding='utf-8') as f:
                        file_content = f.read()
                    return f"File content of {target_path.name}:\n{file_content}"
                else:
                    return f"File {target_path.name} not found."

            elif action.lower() == "write":
                if target_path.suffix.lower() not in allowed_exts:
                    return "File operation error: Only .md and .txt are allowed"
                with target_path.open('w', encoding='utf-8') as f:
                    f.write(content)
                return f"Successfully wrote content to {target_path.name}"

            elif action.lower() == "append":
                if target_path.suffix.lower() not in allowed_exts:
                    return "File operation error: Only .md and .txt are allowed"
                with target_path.open('a', encoding='utf-8') as f:
                    f.write(f"\n\n{content}")
                return f"Successfully appended content to {target_path.name}"

            elif action.lower() == "create_report":
                # Special action for creating structured reports
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                report_content = f"""
# Analysis Report
Generated: {timestamp}

{content}

---
Report generated by Multi-Agent System
"""
                # Always use .md for reports if no extension
                if target_path.suffix == "":
                    target_path = target_path.with_suffix(".md")
                if target_path.suffix.lower() not in allowed_exts:
                    return "File operation error: Only .md and .txt are allowed"
                with target_path.open('w', encoding='utf-8') as f:
                    f.write(report_content)
                return f"Successfully created report: {target_path.name}"

            else:
                return f"Unknown action: {action}. Supported actions: read, write, append, create_report"
        
        except Exception as e:
            return f"File operation error: {str(e)}"

    async def _arun(
        self,
        action: str,
        filename: str,
        content: str = "",
        run_manager: Optional[any] = None,
    ) -> str:
        return self._run(action, filename, content, run_manager)
